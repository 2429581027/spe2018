import os
import json
import numpy as np
import torch
import torch.nn as nn
import torch.utils.data as data
from torch.autograd import Variable
from util.util import batch_rodrigues, center_pts_tensor
from config import args
from SMPL import SMPL
import trimesh

class SmplDataset(data.Dataset):
    '''
        load synthesized smpl data: shape & pose parameters
            default: up orientation is y+; face (front) orientation is z+
            we center the input data generated by SMPL, so the encoder network has to learn a translation besides shape and pose parameters
        
        rot: apply random rotations
            none for no rotation
            pose for rotation with smpl pose parameters, then the encoder network should not have STN moudle.
            data for rotation with a matrix, then the encoder network should have STN moudle.
    '''
    def __init__(self, root, npts = 2400, train = True, rot = 'None'):
        self.npts = npts
        self.root = root
        self.data = []
        self.train = train
        self.rot = rot 
        self.center_input = args.center_input

        # template
        self.smpl = SMPL(args.smpl_model, b_center = True, obj_saveable = True)      

        mesh = trimesh.load("./data/template/template_smpl_mean.ply", process=False)
        a = mesh.vertices[mesh.faces[:, 0]]
        b = mesh.vertices[mesh.faces[:, 1]]
        c = mesh.vertices[mesh.faces[:, 2]]
        cross = np.cross(a - b, a - c)
        area = np.sqrt(np.sum(cross ** 2, axis=1))
        prop = np.zeros((6890))
        prop[mesh.faces[:, 0]] = prop[mesh.faces[:, 0]] + area
        prop[mesh.faces[:, 1]] = prop[mesh.faces[:, 1]] + area
        prop[mesh.faces[:, 2]] = prop[mesh.faces[:, 2]] + area
        prop = prop / np.sum(prop)
        self.prop = prop # prop is the sum of adjacent area of each vertex divided by total area.

        # data
        if self.train:
            self.path = ['spe_dataset_train_w_m200k', 'spe_dataset_train_w_m_bent30k']
            # self.path = ['spe_dataset_train_w_m3', 'spe_dataset_train_w_m4', 'spe_dataset_train_w_m5',
            #                  'spe_dataset_train_w_m4_centered', 'spe_dataset_train_w_m4_centered']            
        else:            
            #self.path = ['spe_dataset_val_w_m_test']
            #self.path = ['spe_dataset_val_w_m100'] # male, 100
            self.path = ['spe_dataset_val_w_m200'] # male, 200
            #self.path = ['spe_dataset_val_w_m_bent100']

        for path in self.path:                
            tmp = os.path.join(self.root, path)
            jsonfile = os.path.join(tmp, 'data.json')

            with open(jsonfile) as json_file:  
                data = json.load(json_file)
                for p in data['people']:
                    self.data.append((p['beta'], p['pose'],p['name']))

    def __getitem__(self, index):
        '''
            output: 
                pts: N x 3;
                shape: 10
                pose: 72
                gtverts: 6890 x 3
                j3d: 19 x 3
        '''
        data = self.data[index]
        shape = torch.tensor( np.array(data[0]) ).float() # (10)
        pose = torch.tensor( np.array(data[1]) ).float() # (72)

        pose[0:3]=0.0 # cancel global transformation, since the SMPL coordinate frame is very strange!!!
        # todo try rotation latter 
        if self.rot == 'pose':      
            #anglex = 0.5 * np.pi; angley = 0.5 * np.pi; anglez = 0.5 * np.pi 
            anglex = 0.0; angley = 0.5 * np.pi; anglez = 0.0 
            pose[0]= anglex * np.random.random() # x axis
            pose[1]= angley * np.random.random()
            pose[2]= anglez * np.pi * np.random.random()
        
        verts, j3d, _ = self.smpl(shape.unsqueeze(0), pose.unsqueeze(0), get_skin = True)
        verts = verts.squeeze(0)
        j3d = j3d.squeeze(0)

        # center input
        if self.center_input:
            translation = center_pts_tensor(verts)
            verts = verts - translation

        if self.rot == 'data':
            # generate random sample on the sphere :
            theta = np.random.uniform(- np.pi, np.pi)
            rot_matrix = np.array([[np.cos(theta), 0, np.sin(theta)], [0, 1, 0], [- np.sin(theta), 0,  np.cos(theta)]])
            # Uncomment these lines to get a uniform 3D rotation of the sphere.
            # x = torch.Tensor(2)
            # x.uniform_()
            # p = torch.Tensor([[np.cos(np.pi  * 2 * x[0] )* np.sqrt(x[1]), (np.random.binomial(1, 0.5, 1)[0]*2 -1) * np.sqrt(1-x[1]), np.sin(np.pi  * 2 * x[0]) * np.sqrt(x[1])]])
            # z = torch.Tensor([[0,1,0]])
            # v = (p-z)/(p-z).norm()
            # H = torch.eye(3) - 2*torch.matmul( v.transpose(1,0), v)
            # rot_matrix = - H.numpy().dot( rot_matrix)
            verts = verts.dot(np.transpose(rot_matrix, (1, 0)))

        # todo try to uncomment this latter
        # translation for robustness
        if self.train:
            a = torch.FloatTensor(3)
            verts = verts + a.uniform_(-1,1) * 0.03

        # sampling     
        random_sample = np.random.choice(verts.shape[0], self.npts, p=self.prop)
        #random_sample = np.random.choice(verts.shape[0], self.npts, replace=False) # replace=False for avoiding to sample a point multiple times        
        pts = verts[random_sample, :] 
        
        results = {
                    'pts': pts,
                    'idx': random_sample, 
                    'verts': verts, #gt
                    'shape': shape, #gt
                    'pose': pose, #gt                   
                    'j3d': j3d, #gt
                    'name': data[2],
                }

        return results

    def __len__(self):
        return len(self.data)


if __name__ == '__main__':
    print('test')
    root = '/data/spe_database_old'
    data_set = SmplDataset(root=root)
    
    print(len(data_set))
    data = data_set[0]
    pts = data['pts']
    shapepara, posepara = data['shape'], data['pose']
    print(pts.size(),shapepara.size(), shapepara.type(), posepara.size())
    if 'verts' in data:
        verts, j3d = data['verts'], data['j3d']

    data_set.smpl.save_obj(verts.numpy(), 'test.obj') 
    data_set.smpl.save_png(pts.numpy(), verts.numpy(), verts.numpy(), 'test.png')    
    print('dataset over')


    from torch.utils.data import DataLoader
    loader = DataLoader(
            dataset = data_set,
            batch_size = 2,
            shuffle = True,
            drop_last = True,
            pin_memory = True,
            num_workers = 2
        )
    loader = iter(loader)
    data = loader.next()
    pts, real_shape, real_pose = data['pts'], data['shape'], data['pose']
    if 'gtmesh' in data:
        verts, j3d = data['gtmesh'], data['j3d']
    print('dataloader over')